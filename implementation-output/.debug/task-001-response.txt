Let me implement the database schema and migrations based on the specification. I'll create the files in sequence using SQLite and TypeORM.

```filepath:src/entities/Base.entity.ts
import { PrimaryGeneratedColumn, CreateDateColumn, UpdateDateColumn, Column } from 'typeorm';

export abstract class BaseEntity {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @CreateDateColumn({ type: 'datetime' })
  created_at: Date;

  @UpdateDateColumn({ type: 'datetime' })
  updated_at: Date;
}
```

```filepath:src/entities/Person.entity.ts
import { Entity, Column, Index, OneToMany } from 'typeorm';
import { BaseEntity } from './Base.entity';
import { Item } from './Item.entity';

@Entity('persons')
export class Person extends BaseEntity {
  @Column({ type: 'varchar', length: 100, nullable: false })
  name: string;

  @Column({ type: 'varchar', length: 255, nullable: true, unique: true })
  @Index('idx_person_email', { unique: true, where: "email IS NOT NULL" })
  email: string;

  @Column({ type: 'varchar', length: 50, nullable: true })
  @Index('idx_person_slack_id', { unique: true, where: "slack_user_id IS NOT NULL" })
  slack_user_id: string;

  @Column({ type: 'varchar', length: 50, nullable: true })
  @Index('idx_person_zoom_id', { unique: true, where: "zoom_user_id IS NOT NULL" })
  zoom_user_id: string;

  @OneToMany(() => Item, item => item.responsible_person)
  items: Item[];
}
```

```filepath:src/entities/Item.entity.ts
import { Entity, Column, ManyToOne, JoinColumn, Index, Check, OneToMany } from 'typeorm';
import { BaseEntity } from './Base.entity';
import { Person } from './Person.entity';
import { Relationship } from './Relationship.entity';
import { ManualEdit } from './ManualEdit.entity';
import { LearningFeedback } from './LearningFeedback.entity';

export type ItemType = 'ask' | 'commitment' | 'action';
export type ItemPriority = 'low' | 'medium' | 'high';
export type ItemStatus = 'pending' | 'in_progress' | 'completed' | 'cancelled';
export type SourceType = 'email' | 'slack' | 'zoom';

@Entity('items')
@Index('idx_items_source', ['source_type', 'source_id'], { unique: true })
@Index('idx_items_status', ['status'])
@Index('idx_items_priority', ['priority'])
@Index('idx_items_due_date', ['due_date'])
@Check(`"type" IN ('ask', 'commitment', 'action')`)
@Check(`"priority" IN ('low', 'medium', 'high')`)
@Check(`"status" IN ('pending', 'in_progress', 'completed', 'cancelled')`)
@Check(`"confidence_score" >= 0 AND "confidence_score" <= 1`)
export class Item extends BaseEntity {
  @Column({ type: 'varchar', length: 200, nullable: false })
  title: string;

  @Column({ type: 'text', nullable: false })
  description: string;

  @Column({ type: 'varchar', length: 20, nullable: false })
  type: ItemType;

  @Column({ type: 'varchar', length: 20, nullable: false })
  priority: ItemPriority;

  @Column({ type: 'varchar', length: 10, nullable: false, default: 'ai' })
  priority_source: 'ai' | 'manual';

  @Column({ type: 'varchar', length: 20, nullable: false })
  status: ItemStatus;

  @Column({ type: 'uuid', nullable: false })
  responsible_person_id: string;

  @ManyToOne(() => Person, person => person.items, { onDelete: 'RESTRICT' })
  @JoinColumn({ name: 'responsible_person_id' })
  responsible_person: Person;

  @Column({ type: 'decimal', precision: 3, scale: 2, nullable: false })
  confidence_score: number;

  @Column({ type: 'varchar', length: 10, nullable: false })
  source_type: SourceType;

  @Column({ type: 'varchar', length: 255, nullable: false })
  source_id: string;

  @Column({ type: 'varchar', length: 1000, nullable: true })
  source_url: string;

  @Column({ type: 'datetime', nullable: true })
  due_date: Date;

  @Column({ type: 'datetime', nullable: true })
  completed_at: Date;

  @Column({ type: 'boolean', default: false })
  flagged_for_followup: boolean;

  @Column({ type: 'datetime', nullable: true })
  flagged_at: Date;

  @Column({ type: 'boolean', default: false })
  archived: boolean;

  @Column({ type: 'datetime', nullable: true })
  archived_at: Date;

  @Column({ type: 'boolean', default: false })
  historical_import: boolean;

  @OneToMany(() => Relationship, relationship => relationship.parent_item)
  child_relationships: Relationship[];

  @OneToMany(() => Relationship, relationship => relationship.child_item)
  parent_relationships: Relationship[];

  @OneToMany(() => ManualEdit, edit => edit.item)
  manual_edits: ManualEdit[];

  @OneToMany(() => LearningFeedback, feedback => feedback.item)
  learning_feedback: LearningFeedback[];
}
```

```filepath:src/entities/Relationship.entity.ts
import { Entity, Column, ManyToOne, JoinColumn, Index, Check } from 'typeorm';
import { BaseEntity } from './Base.entity';
import { Item } from './Item.entity';

export type RelationshipType = 'ask_to_commitment' | 'commitment_to_action';

@Entity('relationships')
@Index('idx_relationship_parent_child', ['parent_item_id', 'child_item_id'], { unique: true })
@Check(`"relationship_type" IN ('ask_to_commitment', 'commitment_to_action')`)
@Check(`"confidence_score" >= 0 AND "confidence_score" <= 1`)
export class Relationship extends BaseEntity {
  @Column({ type: 'uuid', nullable: false })
  parent_item_id: string;

  @Column({ type: 'uuid', nullable: false })
  child_item_id: string;

  @Column({ type: 'varchar', length: 30, nullable: false })
  relationship_type: RelationshipType;

  @Column({ type: 'decimal', precision: 3, scale: 2, nullable: false })
  confidence_score: number;

  @ManyToOne(() => Item, item => item.child_relationships, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'parent_item_id' })
  parent_item: Item;

  @ManyToOne(() => Item, item => item.parent_relationships, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'child_item_id' })
  child_item: Item;
}
```

```filepath:src/entities/ManualEdit.entity.ts
import { Entity, Column, ManyToOne, JoinColumn, Index } from 'typeorm';
import { BaseEntity } from './Base.entity';
import { Item } from './Item.entity';

@Entity('manual_edits')
@Index('idx_manual_edits_item', ['item_id'])
export class ManualEdit extends BaseEntity {
  @Column({ type: 'uuid', nullable: false })
  item_id: string;

  @Column({ type: 'varchar', length: 50, nullable: false })
  field_name: string;

  @Column({ type: 'text', nullable: false })
  old_value: string;

  @Column({ type: 'text', nullable: false })
  new_value: string;

  @Column({ type: 'datetime', nullable: false })
  edited_at: Date;

  @ManyToOne(() => Item, item => item.manual_edits, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'item_id' })
  item: Item;
}
```

```filepath:src/entities/LearningFeedback.entity.ts
import { Entity, Column, ManyToOne, JoinColumn, Index, Check } from 'typeorm';
import { BaseEntity } from './Base.entity';
import { Item } from './Item.entity';

export type FeedbackType = 'priority_correction' | 'false_positive' | 'relationship_correction';

@Entity('learning_feedback')
@Index('idx_learning_feedback_item', ['item_id'])
@Check(`"feedback_type" IN ('priority_correction', 'false_positive', 'relationship_correction')`)
export class LearningFeedback extends BaseEntity {
  @Column({ type: 'uuid', nullable: false })
  item_id: string;

  @Column({ type: 'varchar', length: 30, nullable: false })
  feedback_type: FeedbackType;

  @Column({ type: 'text', nullable: false })
  ai_prediction: string;

  @Column({ type: 'text', nullable: false })
  user_correction: string;

  @ManyToOne(() => Item, item => item.learning_feedback, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'item_id' })
  item: Item;
}
```

```filepath:src/entities/Job.entity.ts
import { Entity, Column, Index, Check } from 'typeorm';
import { BaseEntity } from './Base.entity';

export type JobType = 'process_email' | 'process_slack' | 'process_zoom';
export type JobStatus = 'pending' | 'processing' | 'completed' | 'failed';

@Entity('jobs')
@Index('idx_jobs_source', ['source_id'], { unique: true })
@Index('idx_jobs_status', ['status'])
@Check(`"job_type" IN ('