```filepath:implementation-output/src/entities/Base.entity.ts
import { CreateDateColumn, UpdateDateColumn, PrimaryColumn } from 'typeorm';
import { v4 as uuid } from 'uuid';

export abstract class BaseEntity {
  @PrimaryColumn('uuid')
  id: string = uuid();

  @CreateDateColumn()
  created_at: Date;

  @UpdateDateColumn()
  updated_at: Date;
}
```

```filepath:implementation-output/src/entities/item.entity.ts
import { Entity, Column, ManyToOne, OneToMany, Index } from 'typeorm';
import { BaseEntity } from './Base.entity';
import { Person } from './person.entity';
import { Relationship } from './relationship.entity';
import { ManualEdit } from './ManualEdit.entity';
import { LearningFeedback } from './LearningFeedback.entity';

export type ItemType = 'ask' | 'commitment' | 'action';
export type ItemPriority = 'low' | 'medium' | 'high';
export type ItemStatus = 'pending' | 'in_progress' | 'completed' | 'cancelled';
export type SourceType = 'email' | 'slack' | 'zoom';
export type PrioritySource = 'ai' | 'manual';

@Entity()
export class Item extends BaseEntity {
  @Column({ length: 200 })
  title: string;

  @Column({ length: 2000 })
  description: string;

  @Column({ type: 'enum', enum: ['ask', 'commitment', 'action'] })
  type: ItemType;

  @Column({ type: 'enum', enum: ['low', 'medium', 'high'] })
  priority: ItemPriority;

  @Column({ type: 'enum', enum: ['ai', 'manual'] })
  priority_source: PrioritySource;

  @Column({ type: 'enum', enum: ['pending', 'in_progress', 'completed', 'cancelled'] })
  status: ItemStatus;

  @ManyToOne(() => Person, person => person.items)
  responsible_person: Person;

  @Column('float', { 
    check: 'confidence_score >= 0 AND confidence_score <= 1'
  })
  confidence_score: number;

  @Column({ type: 'enum', enum: ['email', 'slack', 'zoom'] })
  source_type: SourceType;

  @Index({ unique: true })
  @Column()
  source_id: string;

  @Column({ nullable: true })
  source_url?: string;

  @Column({ nullable: true, type: 'timestamp' })
  due_date?: Date;

  @Column({ nullable: true, type: 'timestamp' })
  completed_at?: Date;

  @Column({ default: false })
  flagged_for_followup: boolean;

  @Column({ nullable: true, type: 'timestamp' })
  flagged_at?: Date;

  @Column({ default: false })
  archived: boolean;

  @Column({ nullable: true, type: 'timestamp' })
  archived_at?: Date;

  @Column({ default: false })
  historical_import: boolean;

  @OneToMany(() => Relationship, relationship => relationship.parent_item)
  child_relationships: Relationship[];

  @OneToMany(() => Relationship, relationship => relationship.child_item)
  parent_relationships: Relationship[];

  @OneToMany(() => ManualEdit, edit => edit.item)
  manual_edits: ManualEdit[];

  @OneToMany(() => LearningFeedback, feedback => feedback.item)
  learning_feedback: LearningFeedback[];
}
```

```filepath:implementation-output/src/entities/person.entity.ts
import { Entity, Column, OneToMany, Index } from 'typeorm';
import { BaseEntity } from './Base.entity';
import { Item } from './item.entity';

@Entity()
export class Person extends BaseEntity {
  @Column({ length: 100 })
  name: string;

  @Index({ unique: true, where: 'email IS NOT NULL' })
  @Column({ nullable: true, length: 255 })
  email?: string;

  @Column({ nullable: true })
  slack_user_id?: string;

  @Column({ nullable: true })
  zoom_user_id?: string;

  @OneToMany(() => Item, item => item.responsible_person)
  items: Item[];

  @Column('check ("email" IS NOT NULL OR "slack_user_id" IS NOT NULL OR "zoom_user_id" IS NOT NULL)')
  validateIdentifiers() {
    if (!this.email && !this.slack_user_id && !this.zoom_user_id) {
      throw new Error('Person must have at least one identifier (email, slack_user_id, or zoom_user_id)');
    }
  }
}
```

```filepath:implementation-output/src/entities/relationship.entity.ts
import { Entity, Column, ManyToOne, Check } from 'typeorm';
import { BaseEntity } from './Base.entity';
import { Item } from './item.entity';

export type RelationType = 'ask_to_commitment' | 'commitment_to_action';

@Entity()
@Check('"parent_item_id" != "child_item_id"')
export class Relationship extends BaseEntity {
  @ManyToOne(() => Item, item => item.child_relationships)
  parent_item: Item;

  @ManyToOne(() => Item, item => item.parent_relationships) 
  child_item: Item;

  @Column({ type: 'enum', enum: ['ask_to_commitment', 'commitment_to_action'] })
  relationship_type: RelationType;

  @Column('float', {
    check: 'confidence_score >= 0 AND confidence_score <= 1'
  })
  confidence_score: number;

  @Column('check', {
    expression: `
      (relationship_type = 'ask_to_commitment' AND
       parent_item.type = 'ask' AND 
       child_item.type = 'commitment')
      OR
      (relationship_type = 'commitment_to_action' AND
       parent_item.type = 'commitment' AND
       child_item.type = 'action')
    `
  })
  validateTypes() {
    const valid = (
      (this.relationship_type === 'ask_to_commitment' &&
        this.parent_item.type === 'ask' &&
        this.child_item.type === 'commitment') ||
      (this.relationship_type === 'commitment_to_action' &&
        this.parent_item.type === 'commitment' &&
        this.child_item.type === 'action')
    );
    if (!valid) {
      throw new Error('Invalid relationship type combination');
    }
  }
}
```

```filepath:implementation-output/src/entities/ManualEdit.entity.ts
import { Entity, Column, ManyToOne } from 'typeorm';
import { BaseEntity } from './Base.entity';
import { Item } from './item.entity';

@Entity()
export class ManualEdit extends BaseEntity {
  @ManyToOne(() => Item, item => item.manual_edits)
  item: Item;

  @Column()
  field_name: string;

  @Column('json')
  old_value: string;

  @Column('json')
  new_value: string;

  @Column('timestamp')
  edited_at: Date;
}
```

```filepath:implementation-output/src/entities/LearningFeedback.entity.ts
import { Entity, Column, ManyToOne } from 'typeorm';
import { BaseEntity } from './Base.entity';
import { Item } from './item.entity';

export type FeedbackType = 'priority_correction' | 'false_positive' | 'relationship_correction';

@Entity()
export class LearningFeedback extends BaseEntity {
  @ManyToOne(() => Item, item => item.learning_feedback)
  item: Item;

  @Column({ type: 'enum', enum: ['priority_correction', 'false_positive', 'relationship_correction'] })
  feedback_type: FeedbackType;

  @Column('json')
  ai_prediction: string;

  @Column('json')
  user_correction: string;
}
```